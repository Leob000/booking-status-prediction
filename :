# %%
# ruff: noqa: E402
import sys
from pathlib import Path

import matplotlib.pyplot as plt
import pandas as pd
import numpy as np

# Util to import functions from project root
p = Path.cwd()
root = next(
    (
        parent
        for parent in [p] + list(p.parents)
        if (parent / "pyproject.toml").exists()
    ),
    None,
)
if root is None:
    root = Path.cwd()
sys.path.insert(0, str(root))

# %%
df = pd.read_csv("../src/data/train_data.csv")
df.set_index("row_id", inplace=True)
df.drop(columns=["Unnamed: 0"], inplace=True)
target = "reservation_status"

# Check nans
assert df.isna().sum().unique() == 0

df.head()
# %%
df.describe()
# %%
# Transform "hotel" into is_City_hotel 1 for true, 0 for false
print(df["hotel"].astype("category").value_counts())
df["is_City_hotel"] = (df["hotel"] == "City Hotel").astype(int)
df["is_City_hotel"].value_counts()
df.drop(columns=["hotel"], inplace=True)
# %%
# We differentiate between the home country (PRT) and others
df["country"].value_counts()
df["is_PRT"] = (df["country"] == "PRT").astype(int)
df["is_PRT"].value_counts()
df.drop(columns=["country"], inplace=True)


# %%
def make_percent(col):
    if len(df[col].unique()) >= 100:
        print(f"{col} not plotted too many classes")
        return 0
    if col == target:
        return 0
    meal_target_pct = (
        df.groupby(col)[target]
        .value_counts(normalize=True)
        .unstack(fill_value=0)
        .multiply(100)
    )

    # percentage weight of each class in `col` relative to total rows
    class_pct = (
        df[col]
        .value_counts(normalize=True)
        .multiply(100)
        .reindex(meal_target_pct.index)
        .fillna(0)
    )

    ax = meal_target_pct.plot(kind="bar", stacked=True)
    ax.set_title(f"Reservation Status % by {col}")
    ax.set_xlabel(f"{col}")
    ax.set_ylabel("Reservation Status %")
    ax.legend(
        bbox_to_anchor=(1.05, 1),
        loc="upper left",
        prop={"size": 8},
        handlelength=1,
        handletextpad=0.4,
        borderpad=0.3,
        framealpha=0.9,
    )

    # overlay the class weight as a line on a secondary y-axis
    ax2 = ax.twinx()
    class_pct.plot(kind="line", marker="o", color="k", ax=ax2, linewidth=2)
    ax2.set_ylabel("% of total samples")
    ax2.set_ylim(0, max(100, class_pct.max() * 1.1))

    # annotate class weights
    for x, y in enumerate(class_pct.values):
        ax2.text(
            x,
            y + (ax2.get_ylim()[1] * 0.02),
            f"{y:.1f}%",
            ha="center",
            va="bottom",
            fontsize=8,
        )

    plt.show()


for col in df.columns:
    make_percent(col)
# %%
# % of each target class
# Imbalance
target_pct = df[target].value_counts(normalize=True).multiply(100)
print("Overall Reservation Status %:")
for cls, pct in target_pct.items():
    print(f"  {cls}: {pct:.2f}%")


# %%
# Boxplot for "lead_time", "days_in_waiting_list", "adr"
def plot_boxplot(column, by):
    if column == target:
        return 0
    df.boxplot(column=column, by=by)
    plt.title(f"Boxplot of {column} by {by}")
    plt.suptitle("")
    plt.xlabel(by)
    plt.ylabel(column)
    plt.show()


for col in ["lead_time", "days_in_waiting_list", "adr"]:
    plot_boxplot(col, target)
# %%
# Deletion of adr outlier
# List adr extreme values
adr_extremes = df[df["adr"] > 1000][["adr", target]]
print(adr_extremes)
df = df[df["adr"] <= 1000]
# %%
# Cyclical encoding for arrival date fields: month, week number, day of month
month_map = {
    "January": 1,
    "February": 2,
    "March": 3,
    "April": 4,
    "May": 5,
    "June": 6,
    "July": 7,
    "August": 8,
    "September": 9,
    "October": 10,
    "November": 11,
    "December": 12,
}
# map month names to numbers if necessary
if (
    df["arrival_date_month"].dtype == object
    or df["arrival_date_month"].dtype.name == "category"
):
    month_numbers = (
        df["arrival_date_month"]
        .map(lambda x: month_map.get(str(x), np.nan))
        .astype(float)
    )
else:
    month_numbers = df["arrival_date_month"].astype(float)

df["arrival_month_sin"] = np.sin(2 * np.pi * (month_numbers - 1) / 12)
df["arrival_month_cos"] = np.cos(2 * np.pi * (month_numbers - 1) / 12)

# week numbers (assume 1-52)
week_numbers = df["arrival_date_week_number"].astype(float)
df["arrival_week_sin"] = np.sin(2 * np.pi * (week_numbers - 1) / 52)
df["arrival_week_cos"] = np.cos(2 * np.pi * (week_numbers - 1) / 52)

# day of month (1-31)
day_numbers = df["arrival_date_day_of_month"].astype(float)
df["arrival_day_sin"] = np.sin(2 * np.pi * (day_numbers - 1) / 31)
df["arrival_day_cos"] = np.cos(2 * np.pi * (day_numbers - 1) / 31)


def plot_circular(name, tick_numbers=None, tick_label_fn=None, figsize=(6, 6)):
    """
    Plot a unit circle scatter of `<name>_cos` vs `<name>_sin` colored by the target.
    - `name` examples: 'arrival_month', 'arrival_week', 'arrival_day'
    - `tick_numbers`: iterable of integers (1-indexed) to annotate around the circle (e.g., months 1..12)
    - `tick_label_fn`: function mapping integer -> label string for the tick (optional)
    """
    cos_col = f"{name}_cos"
    sin_col = f"{name}_sin"
    if cos_col not in df.columns or sin_col not in df.columns:
        print(f"Missing columns for {name}: {cos_col}, {sin_col}")
        return

    fig, ax = plt.subplots(figsize=figsize)
    ax.set_aspect("equal")
    theta = np.linspace(0, 2 * np.pi, 300)
    ax.plot(np.cos(theta), np.sin(theta), color="lightgray", linewidth=1)  # unit circle

    # scatter points colored by target class
    classes = df[target].astype(str).unique()
    cmap = plt.cm.get_cmap("tab10", len(classes))
    for i, cls in enumerate(classes):
        sub = df[df[target].astype(str) == cls]
        ax.scatter(
            sub[cos_col],
            sub[sin_col],
            s=20,
            alpha=0.5,
            color=cmap(i),
            label=cls,
            edgecolors="none",
        )

    # plot class centers
    means = df.groupby(target)[[cos_col, sin_col]].mean()
    ax.scatter(
        means[cos_col],
        means[sin_col],
        s=120,
        facecolors="none",
        edgecolors="k",
        linewidths=1.5,
    )
    for cls, row in means.iterrows():
        ax.annotate(
            str(cls),
            (row[cos_col], row[sin_col]),
            fontsize=9,
            fontweight="bold",
            ha="center",
            va="center",
        )

    # optional tick annotations (e.g., month names)
    if tick_numbers is not None:
        max_tick = max(tick_numbers)
        for n in tick_numbers:
            # Compute angle consistent with encoding: angle = 2*pi*(n-1)/period
            period = (
                max_tick if max_tick > 12 else max_tick
            )  # weeks/days handled by passing appropriate tick_numbers
            angle = 2 * np.pi * (n - 1) / period
            x, y = np.cos(angle), np.sin(angle)
            ax.plot(
                [0.92 * x, 1.05 * x], [0.92 * y, 1.05 * y], color="k", linewidth=0.8
            )
            label = tick_label_fn(n) if tick_label_fn is not None else str(n)
            ax.text(1.12 * x, 1.12 * y, label, ha="center", va="center", fontsize=8)

    ax.set_xlabel(f"{name} (cos)")
    ax.set_ylabel(f"{name} (sin)")
    ax.set_title(f"Circular plot for {name} (colored by {target})")
    ax.legend(bbox_to_anchor=(1.05, 1), loc="upper left", prop={"size": 8})
    plt.tight_layout()
    plt.show()


# Prepare tick label helpers
num_to_month = {v: k[:3] for k, v in month_map.items()}  # Jan, Feb, ...
# Plot month with month names around the circle
plot_circular(
    "arrival_month",
    tick_numbers=list(range(1, 13)),
    tick_label_fn=lambda n: num_to_month.get(n, str(n)),
    figsize=(7, 7),
)

# Plot week with sparser tick labels (every 4 weeks)
plot_circular(
    "arrival_week",
    tick_numbers=list(range(1, 53, 4)),
    tick_label_fn=lambda n: str(n),
    figsize=(6, 6),
)

# Plot day with sparser tick labels (every 5 days)
plot_circular(
    "arrival_day",
    tick_numbers=list(range(1, 32, 5)),
    tick_label_fn=lambda n: str(n),
    figsize=(6, 6),
)

# drop original columns
df.drop(
    columns=[
        "arrival_date_month",
        "arrival_date_week_number",
        "arrival_date_day_of_month",
    ],
    inplace=True,
)
